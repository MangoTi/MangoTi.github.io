### 第一章 作用域
1. 作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。

2. 如果查找的目的是对变量进行赋值，那么就会使用 LHS 查询；如果目的是获取变量的值，就会使用 RHS 查询。赋值操作符会导致 LHS 查询。＝操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。

3. JavaScript 引擎首先会在代码执行前对其进行编译，在这个过程中，像 var a = 2 这样的声 明会被分解成两个独立的步骤：
	1. 首先，var a 在其作用域中声明新变量。这会在最开始的阶段，也就是代码执行前进行
	2. 接下来，a = 2 会查询（LHS 查询）变量 a 并对其进行赋值。

4. LHS 和 RHS 查询都会在当前执行作用域中开始，如果有需要（也就是说它们没有找到所 需的标识符），就会向上级作用域继续查找目标标识符，这样每次上升一级作用域（一层 楼），最后抵达全局作用域（顶层），无论找到或没找到都将停止。

5. 不成功的 RHS 引用会导致抛出 ReferenceError 异常。不成功的 LHS 引用会导致自动隐式 地创建一个全局变量（非严格模式下），该变量使用 LHS 引用的目标作为标识符，或者抛出 ReferenceError 异常（严格模式下）。

### 第二章 词法作用域
1. 作用域共有两种主要的工作模型。第一种是最为普遍的，被大多数编程语言所采用的词法作用域，我们会对这种作用域进行深入讨论。另外一种叫作动态作用域，仍有一些编程语 言在使用（比如 Bash 脚本、Perl 中的一些模式等）

2. 词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。编译的词法分析阶段基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它们进行查找。

3. JavaScript 中有两个机制可以“欺骗”词法作用域：eval(..) 和 with。
	1. 前者可以对一段包 含一个或多个声明的“代码”字符串进行演算，并借此来修改已经存在的词法作用域（在运行时）。
	2. 后者本质上是通过将一个对象的引用当作作用域来处理，将对象的属性当作作用域中的标识符来处理，从而创建了一个新的词法作用域（同样是在运行时）。

这两个机制的副作用是引擎无法在编译时对作用域查找进行优化，因为引擎只能谨慎地认为这样的优化是无效的。使用这其中任何一个机制都将导致代码运行变慢。不要使用它们。

### 第三章 函数作用域和块作用域
1. 函数是 JavaScript 中最常见的作用域单元。本质上，声明在一个函数内部的变量或函数会 在所处的作用域中“隐藏”起来，这是有意为之的良好软件的设计原则。 
2. 块作用：函数不是唯一的作用域单元。块作用域指的是变量和函数不仅可以属于所处的作用域， 也可以属于某个代码块（通常指 { .. } 内部）。 
3. 从 ES3 开始，try/catch 结构在 catch 分句中具有块作用域。 在 ES6 中引入了 let 关键字（var 关键字的表亲），用来在任意代码块中声明变量。if (..) { let a = 2; } 会声明一个劫持了 if 的 { .. } 块的变量，并且将变量添加到这个块中。
4. 有些人认为块作用域不应该完全作为函数作用域的替代方案。两种功能应该同时存在，开发者可以并且也应该根据需要选择使用何种作用域，创造可读、可维护的优良代码。

### 第四章 提升
1. 变量提升实际就是变量的声明会在编译时期就进行，而赋值在执行时才进行，这个过程就好像变量和函数声明从它们在代码中出现的位置被“移动” 到了最上面。这个过程就叫作提升。只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。
2. 每个作用域都会进行提升操作，将本作用域的声明提升到本作用域的最上面。
